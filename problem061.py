#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# The Euler Project: problem 061
#
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
#
# Triangle    P3,n=n(n+1)/2   1, 3, 6, 10, 15, ...
# Square    P4,n=n2   1, 4, 9, 16, 25, ...
# Pentagonal    P5,n=n(3n1)/2   1, 5, 12, 22, 35, ...
# Hexagonal   P6,n=n(2n1)   1, 6, 15, 28, 45, ...
# Heptagonal    P7,n=n(5n3)/2   1, 7, 18, 34, 55, ...
# Octagonal   P8,n=n(3n2)   1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
#
# The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

from decorators import benchmark
from collections import defaultdict
import itertools

@benchmark
def solve():
  class Node:
    def __init__(self, value=0, parent=None, poly=None):
      self.value = value
      self.parent = parent
      self.poly = poly

    def __str__(self):
      return str(self.parent) + " -> %d" % self.value

    def steps(self):
      if self.parent is None:
        return 1
      return self.parent.steps() + 1

    def sum(self):
      if self.parent is None:
        return self.value
      return self.parent.sum() + self.value

    def polys(self):
      p,polys = self,[self.poly]
      while p.parent is not None:
        p = p.parent
        polys.append(p.poly)
      return polys

    def is_cyclic(self):
      if self.parent is None:
        return False
      granpa = self.parent
      while granpa.parent is not None:
        granpa = granpa.parent
      return str(self.value)[-2:] == str(granpa.value)[:2]


  def polygonal_number(size,n):
    return int(0.5*n*((size-2)*n + (4-size)))

  d = defaultdict(list)
  for s in range(3,8+1):
    i,p = 1,0
    while p < 10000:
      if p > 999:
        d[s].append(p)
      p = polygonal_number(s,i)
      i += 1
  print "4 digits polygonal numbers loaded for sizes = %s" % d.keys()

  def is_cycle_pair(a,b):
    return str(a)[-2:] == str(b)[:2]

  nodes = [Node(t,poly=3) for t in d[3]]
  for node in nodes:
    while node.steps() < 6:
      r = str(node.value)[-2:]
      others = sorted(list(itertools.chain(((k,v) for k,vlist in d.items() for v in vlist if k not in node.polys()))))
      for k,o in others:
        if is_cycle_pair(r,o):
          nodes.append(Node(o,parent=node,poly=k))
      else:
        break
    if node.steps() == 6 and node.is_cyclic(): 
      #return str(node), node.polys(), node.steps(), node.is_cyclic()
      return node.sum(), str(node)

  return "[result]"

if __name__ == "__main__":
  solve()